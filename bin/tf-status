#!/usr/bin/env bash

set -euo pipefail

# tf-status - Taskforce status dashboard
# Shows agents, activity, requirements progress, and alerts

# Calculate taskforce root from script location (parent of bin/)
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
TASKFORCE_ROOT="$(dirname "$SCRIPT_DIR")"
REGISTRY_FILE="$TASKFORCE_ROOT/bin/.registration.log"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

usage() {
    cat <<EOF
Usage: tf-status [task-id]

Show taskforce status dashboard.

Arguments:
    task-id     Task to show status for (optional if registered)

Options:
    --help, -h  Show this help message

Output includes:
    - Active agents and their last activity
    - Requirements checklist progress
    - Recent chat entries
    - Alerts (silent agents, etc.)

Examples:
    tf-status                    # Use task from registration
    tf-status fix-flaky-ci       # Specific task

EOF
}

error() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit 1
}

# ─────────────────────────────────────────────────────────────────────────────
# REGISTRATION HELPERS
# ─────────────────────────────────────────────────────────────────────────────

get_session_registration() {
    local session_id="${TF_SESSION_ID:-}"
    [[ -z "$session_id" ]] && return 1
    [[ ! -f "$REGISTRY_FILE" ]] && return 1

    local current_task=""
    local current_name=""

    while IFS=, read -r sid tid nm status ts; do
        [[ "$sid" != "$session_id" ]] && continue

        if [[ "$status" == "active" ]]; then
            current_task="$tid"
            current_name="$nm"
        elif [[ "$status" == "replaced" || "$status" == "left" || "$status" == "claimed" || "$status" == "cleared" ]]; then
            if [[ "$tid" == "$current_task" && "$nm" == "$current_name" ]]; then
                current_task=""
                current_name=""
            fi
        fi
    done < <(tail -n +2 "$REGISTRY_FILE")

    if [[ -n "$current_task" ]]; then
        echo "$current_task"
        return 0
    fi
    return 1
}

# Get all active agents for a task (bash 3.x compatible)
get_active_agents() {
    local task="$1"
    [[ ! -f "$REGISTRY_FILE" ]] && return 0

    # Use awk to track agent status and output only active ones
    tail -n +2 "$REGISTRY_FILE" | awk -F, -v task="$task" '
    $2 == task {
        name = $3
        status = $4
        if (status == "active") {
            agents[name] = 1
        } else if (status == "replaced" || status == "left" || status == "claimed" || status == "cleared") {
            delete agents[name]
        }
    }
    END {
        for (name in agents) {
            printf "%s ", name
        }
    }'
}

# ─────────────────────────────────────────────────────────────────────────────
# TIME HELPERS
# ─────────────────────────────────────────────────────────────────────────────

parse_timestamp() {
    local ts="$1"
    date -j -f "%Y-%m-%d %H:%M:%S" "$ts" "+%s" 2>/dev/null || \
    date -j -f "%Y-%m-%dT%H:%M:%S" "$ts" "+%s" 2>/dev/null || \
    date -d "$ts" "+%s" 2>/dev/null || \
    echo "0"
}

format_time_ago() {
    local seconds="$1"
    if [[ $seconds -lt 60 ]]; then
        echo "${seconds}s ago"
    elif [[ $seconds -lt 3600 ]]; then
        echo "$((seconds / 60))m ago"
    elif [[ $seconds -lt 86400 ]]; then
        echo "$((seconds / 3600))h $((seconds % 3600 / 60))m ago"
    else
        echo "$((seconds / 86400))d ago"
    fi
}

# Get agent stats from chat log (bash 3.x compatible)
# Output format: agent|last_time|last_type|count
get_agent_stats() {
    local chat_log="$1"
    [[ ! -f "$chat_log" ]] && return 0

    awk '
    /^### \[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\] [a-z]+ \| [A-Z]+/ {
        # Extract timestamp, agent, type from header line
        match($0, /\[([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})\] ([a-z]+) \| ([A-Z]+)/, arr)
        if (RSTART > 0) {
            ts = arr[1]
            agent = arr[2]
            type = arr[3]
        } else {
            # Fallback parsing for older awk
            gsub(/^### \[/, "")
            gsub(/\].*/, "")
            ts = $0
            # Re-read line for agent and type
        }
    }
    /^### / {
        # Simpler parsing that works with all awk versions
        line = $0
        gsub(/^### \[/, "", line)
        split(line, parts, /\] /)
        ts = parts[1]
        rest = parts[2]
        split(rest, parts2, / \| /)
        agent = parts2[1]
        type = parts2[2]

        if (agent != "" && ts != "") {
            last_time[agent] = ts
            last_type[agent] = type
            count[agent]++
        }
    }
    END {
        for (agent in last_time) {
            print agent "|" last_time[agent] "|" last_type[agent] "|" count[agent]
        }
    }' "$chat_log"
}

# ─────────────────────────────────────────────────────────────────────────────
# MAIN
# ─────────────────────────────────────────────────────────────────────────────

main() {
    local task=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                usage
                exit 0
                ;;
            -*)
                error "Unknown option: $1\nUse 'tf-status --help' for usage."
                ;;
            *)
                task="$1"
                shift
                ;;
        esac
    done

    # Get task from registration if not provided
    if [[ -z "$task" ]]; then
        task=$(get_session_registration 2>/dev/null) || true
        if [[ -z "$task" ]]; then
            error "No task specified and not registered.\nUsage: tf-status <task-id>"
        fi
    fi

    local task_dir="$TASKFORCE_ROOT/$task"
    if [[ ! -d "$task_dir" ]]; then
        error "Task '$task' does not exist.\nExpected directory: $task_dir"
    fi

    local chat_log="$task_dir/.chat.log"
    local task_file="$task_dir/TASK.md"
    local now_epoch=$(date '+%s')

    # ─────────────────────────────────────────────────────────────────────────
    # HEADER
    # ─────────────────────────────────────────────────────────────────────────

    echo -e "${BOLD}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}TASKFORCE STATUS: ${CYAN}$task${NC}"
    echo -e "${BOLD}═══════════════════════════════════════════════════════════${NC}"
    echo ""

    # ─────────────────────────────────────────────────────────────────────────
    # AGENTS
    # ─────────────────────────────────────────────────────────────────────────

    echo -e "${BOLD}Agents${NC}"

    # Get registered agents
    local registered_agents
    registered_agents=$(get_active_agents "$task")

    if [[ -z "$registered_agents" ]]; then
        echo -e "  ${DIM}No agents registered${NC}"
    else
        # Get agent stats from chat log
        local stats_data
        stats_data=$(get_agent_stats "$chat_log")

        # Display each agent
        for agent in $registered_agents; do
            local last_time=""
            local last_type=""
            local entry_count="0"
            local time_ago=""
            local status_color="$NC"
            local silence_warning=""

            # Find this agent's stats
            if [[ -n "$stats_data" ]]; then
                local agent_line
                agent_line=$(echo "$stats_data" | grep "^${agent}|" || true)
                if [[ -n "$agent_line" ]]; then
                    last_time=$(echo "$agent_line" | cut -d'|' -f2)
                    last_type=$(echo "$agent_line" | cut -d'|' -f3)
                    entry_count=$(echo "$agent_line" | cut -d'|' -f4)
                fi
            fi

            if [[ -n "$last_time" ]]; then
                local last_epoch
                last_epoch=$(parse_timestamp "$last_time")
                local diff=$((now_epoch - last_epoch))
                time_ago=$(format_time_ago "$diff")

                # Color based on recency
                if [[ $diff -lt 300 ]]; then
                    status_color="$GREEN"
                elif [[ $diff -lt 600 ]]; then
                    status_color="$YELLOW"
                else
                    status_color="$RED"
                    silence_warning=" ${RED}!${NC}"
                fi
            else
                time_ago="no activity"
                status_color="$DIM"
            fi

            printf "  ${BOLD}%-8s${NC} " "$agent"
            if [[ -n "$last_type" ]]; then
                printf "${status_color}%-10s${NC} " "$last_type"
            else
                printf "${DIM}%-10s${NC} " "-"
            fi
            printf "%3d msgs | " "$entry_count"
            printf "${status_color}%s${NC}%s\n" "$time_ago" "$silence_warning"
        done
    fi
    echo ""

    # ─────────────────────────────────────────────────────────────────────────
    # REQUIREMENTS
    # ─────────────────────────────────────────────────────────────────────────

    echo -e "${BOLD}Requirements${NC}"

    if [[ -f "$task_file" ]]; then
        local total=0
        local done_count=0

        while IFS= read -r line; do
            if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\[[[:space:]]\] ]]; then
                total=$((total + 1))
            elif [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\[[xX]\] ]]; then
                total=$((total + 1))
                done_count=$((done_count + 1))
            fi
        done < "$task_file"

        if [[ $total -eq 0 ]]; then
            echo -e "  ${DIM}No requirements defined${NC}"
        else
            local pct=0
            if [[ $total -gt 0 ]]; then
                pct=$((done_count * 100 / total))
            fi

            # Progress bar
            local bar_width=30
            local filled=$((pct * bar_width / 100))
            local empty=$((bar_width - filled))
            local bar=""
            local i
            for ((i=0; i<filled; i++)); do bar+="█"; done
            for ((i=0; i<empty; i++)); do bar+="░"; done

            local color="$RED"
            if [[ $pct -ge 100 ]]; then
                color="$GREEN"
            elif [[ $pct -ge 50 ]]; then
                color="$YELLOW"
            fi

            echo -e "  ${color}[$bar]${NC} $done_count/$total ($pct%)"

            # Show individual requirements
            echo ""
            while IFS= read -r line; do
                if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\[[[:space:]]\][[:space:]]*(.*) ]]; then
                    local req="${BASH_REMATCH[1]}"
                    req="${req#<!--}"
                    req="${req%-->}"
                    req="${req# }"
                    req="${req% }"
                    if [[ -n "$req" && "$req" != "Requirement"* ]]; then
                        echo -e "  ${RED}○${NC} $req"
                    fi
                elif [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\[[xX]\][[:space:]]*(.*) ]]; then
                    local req="${BASH_REMATCH[1]}"
                    req="${req#<!--}"
                    req="${req%-->}"
                    req="${req# }"
                    req="${req% }"
                    if [[ -n "$req" && "$req" != "Requirement"* ]]; then
                        echo -e "  ${GREEN}●${NC} $req"
                    fi
                fi
            done < "$task_file"
        fi
    else
        echo -e "  ${DIM}No TASK.md found${NC}"
    fi
    echo ""

    # ─────────────────────────────────────────────────────────────────────────
    # RECENT ACTIVITY
    # ─────────────────────────────────────────────────────────────────────────

    echo -e "${BOLD}Recent Activity${NC}"

    if [[ -f "$chat_log" ]]; then
        # Use tail and awk to get last 5 entries
        local recent
        recent=$(awk '
        /^### / {
            if (entry != "") {
                entries[entry_count++] = entry
            }
            entry = $0
            next
        }
        entry != "" && /^[^#]/ && first_line == "" {
            first_line = $0
            entry = entry "|" first_line
        }
        /^$/ {
            first_line = ""
        }
        END {
            if (entry != "") {
                entries[entry_count++] = entry
            }
            # Print last 5
            start = entry_count - 5
            if (start < 0) start = 0
            for (i = entry_count - 1; i >= start; i--) {
                print entries[i]
            }
        }' "$chat_log")

        if [[ -z "$recent" ]]; then
            echo -e "  ${DIM}No activity yet${NC}"
        else
            echo "$recent" | while IFS= read -r entry; do
                # Parse: ### [timestamp] agent | TYPE|first line of message
                local header msg
                header=$(echo "$entry" | cut -d'|' -f1)
                msg=$(echo "$entry" | cut -d'|' -f2-)

                # Extract parts from header
                local ts ag ty
                ts=$(echo "$header" | sed 's/^### \[\([^]]*\)\].*/\1/')
                ag=$(echo "$header" | sed 's/.*\] \([a-z]*\) |.*/\1/')
                ty=$(echo "$header" | sed 's/.*| \([A-Z]*\).*/\1/')

                local time_only
                time_only=$(echo "$ts" | cut -d' ' -f2)

                # Truncate message
                msg=$(echo "$msg" | tr '\n' ' ' | sed 's/  */ /g')
                msg="${msg:0:45}"
                [[ ${#msg} -ge 45 ]] && msg="$msg..."

                echo -e "  ${CYAN}[$time_only]${NC} ${BOLD}$ag${NC} | $ty - $msg"
            done
        fi
    else
        echo -e "  ${DIM}No chat log found${NC}"
    fi
    echo ""

    # ─────────────────────────────────────────────────────────────────────────
    # ALERTS
    # ─────────────────────────────────────────────────────────────────────────

    local has_alerts=false

    # Check for silent agents (> 10 minutes)
    if [[ -n "$registered_agents" && -f "$chat_log" ]]; then
        local stats_data
        stats_data=$(get_agent_stats "$chat_log")

        for agent in $registered_agents; do
            local last_time=""
            local agent_line
            agent_line=$(echo "$stats_data" | grep "^${agent}|" || true)
            if [[ -n "$agent_line" ]]; then
                last_time=$(echo "$agent_line" | cut -d'|' -f2)
            fi

            local last_epoch=0
            if [[ -n "$last_time" ]]; then
                last_epoch=$(parse_timestamp "$last_time")
            fi
            local silence=$((now_epoch - last_epoch))

            if [[ $silence -gt 600 ]]; then
                if [[ "$has_alerts" == false ]]; then
                    echo -e "${YELLOW}${BOLD}Alerts${NC}"
                    has_alerts=true
                fi
                local silence_mins=$((silence / 60))
                echo -e "  ${YELLOW}!${NC} ${BOLD}$agent${NC} has been silent for ${silence_mins}m"
            fi
        done
    fi

    if [[ "$has_alerts" == true ]]; then
        echo ""
    fi
}

main "$@"
